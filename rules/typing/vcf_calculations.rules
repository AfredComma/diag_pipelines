rule calculate_statistics_from_vcf_to_reference:
    conda:
        "env/vt-bcftools.yaml"
    input:
        "strains/{sample}/snps/{snp_caller}/{ref}/{mapping_method}/{sample}.vcf.gz",
    output:
        "strains/{sample}/snps/{snp_caller}/{ref}/{mapping_method}/final_stats.txt",
    shell:
        """
        bcftools stats -f PASS {input[0]} > {output[0]}
        """
        
        
rule calculate_statistics_from_pairs_of_vcf:
    conda:
        "env/vt-bcftools.yaml"
    input:
        "strains/{sample1}/snps/{snp_caller}/{ref}/{mapping_method}/{sample1}.vcf.gz",
        "strains/{sample2}/snps/{snp_caller}/{ref}/{mapping_method}/{sample2}.vcf.gz",
    output:
        "typing/{snp_caller}/core_parsnp/{ref}/{mapping_method}/{sample1}_{sample2}_stats.txt"
    shell:
        """
        bcftools stats {input} > {output[0]}
        """
        
rule calculate_complement_sites_from_pairs_of_vcf:
    conda:
        "env/vt-bcftools.yaml"
    input:
        "strains/{sample1}/snps/{snp_caller}/{ref}/{mapping_method}/{sample1}.vcf.gz",
        "strains/{sample2}/snps/{snp_caller}/{ref}/{mapping_method}/{sample2}.vcf.gz",
    output:
        "typing/{snp_caller}/core_parsnp/{ref}/{mapping_method}/{sample1}_{sample2}_complements.txt",
        "typing/{snp_caller}/core_parsnp/{ref}/{mapping_method}/{sample2}_{sample1}_complements.txt",
        "typing/{snp_caller}/core_parsnp/{ref}/{mapping_method}/{sample2}_{sample1}_distance.txt",
    shell:
        """
        bcftools isec -C -e "filter!='PASS'" -e- {input[0]} {input[1]} > {output[0]}
        bcftools isec -C -e "filter!='PASS'" -e- {input[1]} {input[0]} > {output[1]}
        echo {wildcards.sample1} {wildcards.sample2} $(( $(wc -l < {output[0]}) + $(wc -l < {output[1]}) )) >> {output[2]}
        """


rule calculate_distances_from_merged_pairs_of_vcf:
    conda:
        "env/vt-bcftools.yaml"
    input:
        pairs=expand("typing/{{snp_caller}}/core_parsnp/{{ref}}/{{mapping_method}}/{sample1}_{sample2}.vcf", zip, sample1 = s1, sample2 = s2),
        to_ref=expand("strains/{sample}/snps/{{snp_caller}}/{{ref}}/{{mapping_method}}/final_stats.txt", sample=read_naming.keys())
    output:
        "typing/{snp_caller}/core_parsnp/{ref}/{mapping_method}/other_distances.txt"
    shell:
        """
        for i in {input[pairs]}
        do
            snps=$(bcftools stats -f PASS ${{i}} | grep "^SiS" | cut -f 4)
            id="$(echo ${{i}} | sed "s/.*\///" | sed "s/\.vcf//" | sed "s/_/ /") "
            echo ${{id}} ${{snps}} >> {output[0]}
        done
        for i in {input[to_ref]}
        do
            id="$(echo ${{i}} | sed "s/strains\///" | sed "s/\/.*//") {wildcards.ref}"
            snps=$(grep "^SN" ${{i}} | grep "SNPs" | awk '$2 !=2 {{print $NF}}' | awk '{{count=count+$1}}END{{print count}}') 
            echo ${{id}} ${{snps}} >> {output[0]}
        done
        """

rule calculate_distances_from_complement_files:
    input:
        pairs=expand("typing/{{snp_caller}}/core_parsnp/{{ref}}/{{mapping_method}}/{sample1}_{sample2}_distance.txt", zip, sample1 = s1, sample2 = s2),
        to_ref=expand("strains/{sample}/snps/{{snp_caller}}/{{ref}}/{{mapping_method}}/final_stats.txt", sample=read_naming.keys())
    output:
        "typing/{snp_caller}/core_parsnp/{ref}/{mapping_method}/complements_distances.txt"
    shell:
        """
        cat {input[pairs]} > {output[0]}
        for i in {input[to_ref]}
        do
            id="$(echo ${{i}} | sed "s/strains\///" | sed "s/\/.*//") {wildcards.ref}"
            snps=$(grep "^SN" ${{i}} | grep "SNPs" | awk '$2 !=2 {{print $NF}}' | awk '{{count=count+$1}}END{{print count}}') 
            echo ${{id}} ${{snps}} >> {output[0]}
        done
        """

        
rule extract_alignment_for_phylogeny:
    input:
        "typing/{snp_caller}/core_parsnp/{ref}/{mapping_method}/merged.vcf.gz",
    output:
        "typing/{snp_caller}/core_parsnp/{ref}/{mapping_method}/alignment.fa"
    shell:
        """
        printf ">{wildcards.ref}\\n" > {output[0]}
        bcftools query -f %REF {input[0]} >> {output[0]}
        printf "\\n" >> {output[0]}
        for samp in $(bcftools query -l {input[0]})
        do
            printf '>'${{samp}}'\\n' 
            bcftools query -s ${{samp}} -f '[%TGT]' {input[0]} | sed "s/\./N/g"
            printf '\\n'
        done >> {output[0]}
        """

