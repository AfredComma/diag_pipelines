rule coverage_filtering:
    conda:
        "env/vt-bcftools.yaml"
    input:
        "strains/{sample}/snps/{snp_caller}/{ref}/{mapping_method}/snps.vcf",
        "strains/{sample}/quality/mapping/bwa/{ref}/max_cov.txt"
    output:
        "strains/{sample}/snps/{snp_caller}/{ref}/{mapping_method}/coverage_filtered.vcf.gz",
        "strains/{sample}/snps/{snp_caller}/{ref}/{mapping_method}/coverage_filtered.vcf.gz.tbi",
    shell:
        """
        min=10
        max=$(cat {input[1]})
        min_freq=0.75
        bcftools filter -s "lowcov" -S "." -e "DP<${{min}}" {input[0]} | bcftools filter -s "hicov" -S "." -e "DP>${{max}}" | bcftools filter -s "freq" -S "." -e "(AO/DP)<${{min_freq}}" -O v - | bgzip > {output[0]}
        tabix -f -p vcf {output[0]}
        """

rule vt_decompose_blocksub:
    conda:
        "env/vt-bcftools.yaml"
    input:
        "strains/{sample}/snps/{snp_caller}/{ref}/{mapping_method}/coverage_filtered.vcf.gz",
    output:
        "strains/{sample}/snps/{snp_caller}/{ref}/{mapping_method}/mnp_decomposed_coverage_filtered.vcf.gz",
        "strains/{sample}/snps/{snp_caller}/{ref}/{mapping_method}/mnp_decomposed_coverage_filtered.vcf.gz.tbi",
        "strains/{sample}/snps/{snp_caller}/{ref}/{mapping_method}/mnp_decomposed_coverage_filtered.vcf",
    shell:
        """
        vt decompose_blocksub {input[0]} -o {output[2]}
        bgzip -c {output[2]} > {output[0]}
        tabix -f -p vcf {output[0]}
        """

rule filter_core_genome_parsnp:
    conda:
        "env/vt-bcftools.yaml"
    input:
        "core_genome/{ref}_core_parsnp_sorted_withdot.bed",
        "strains/{sample}/snps/{snp_caller}/{ref}/{mapping_method}/mnp_decomposed_coverage_filtered.vcf.gz",
    output:
        "strains/{sample}/snps/{snp_caller}/{ref}/{mapping_method}/{sample}.vcf.gz",
        "strains/{sample}/snps/{snp_caller}/{ref}/{mapping_method}/{sample}.vcf.gz.tbi",
        "strains/{sample}/snps/{snp_caller}/{ref}/{mapping_method}/{sample}.vcf",
    shell:
        """
        bcftools view -R {input[0]} {input[1]} | bcftools sort -O v - > {output[2]}
        bgzip -c {output[2]} > {output[0]}
        tabix -f -p vcf {output[0]}
        """


        
rule stats_compared_to_reference:
    conda:
        "env/vt-bcftools.yaml"
    input:
        "strains/{sample}/snps/{snp_caller}/{ref}/{mapping_method}/{sample}.vcf.gz",
    output:
        "strains/{sample}/snps/{snp_caller}/{ref}/{mapping_method}/final_stats.txt",
    shell:
        """
        bcftools stats -f PASS,. {input[0]} > {output[0]}
        """
        
        
rule stats_pairs_calculation:
    conda:
        "env/vt-bcftools.yaml"
    input:
        "strains/{sample1}/snps/{snp_caller}/{ref}/{mapping_method}/{sample1}.vcf.gz",
        "strains/{sample2}/snps/{snp_caller}/{ref}/{mapping_method}/{sample2}.vcf.gz",
    output:
        "typing/{snp_caller}/core_parsnp/{ref}/{mapping_method}/{sample1}_{sample2}_stats.txt"
    shell:
        """
        bcftools stats -e "GT='.'" {input} > {output[0]}
        """
        

        
rule complement_pairs_calculation:
    conda:
        "env/vt-bcftools.yaml"
    input:
        "strains/{sample1}/snps/{snp_caller}/{ref}/{mapping_method}/{sample1}.vcf.gz",
        "strains/{sample2}/snps/{snp_caller}/{ref}/{mapping_method}/{sample2}.vcf.gz",
    output:
        "typing/{snp_caller}/core_parsnp/{ref}/{mapping_method}/{sample1}_{sample2}_complements.txt",
        "typing/{snp_caller}/core_parsnp/{ref}/{mapping_method}/{sample2}_{sample1}_complements.txt",
        "typing/{snp_caller}/core_parsnp/{ref}/{mapping_method}/{sample2}_{sample1}_distance.txt",
    shell:
        """
        bcftools isec -C -e "filter!='PASS'" -e- {input[0]} {input[1]} > {output[0]}
        bcftools isec -C -e "filter!='PASS'" -e- {input[1]} {input[0]} > {output[1]}
        echo {wildcards.sample1} {wildcards.sample2} $(( $(wc -l < {output[0]}) + $(wc -l < {output[1]}) )) >> {output[2]}
        """

rule merge_complement_pairs_calculation:
    input:
        pairs=expand("typing/{{snp_caller}}/core_parsnp/{{ref}}/{{mapping_method}}/{sample1}_{sample2}_distance.txt", zip, sample1 = s1, sample2 = s2),
        to_ref=expand("strains/{sample}/snps/{{snp_caller}}/{{ref}}/{{mapping_method}}/final_stats.txt", sample=read_naming.keys())
    output:
        "typing/{snp_caller}/core_parsnp/{ref}/{mapping_method}/complements_distances.txt"
    shell:
        """
        cat {input[pairs]} > {output[0]}
        for i in {input[to_ref]}
        do
            id="$(echo ${{i}} | sed "s/strains\///" | sed "s/\/.*//") {wildcards.ref}"
            snps=$(grep "^SN" ${{i}} | grep "SNPs" | awk '$2 !=2 {{print $NF}}' | awk '{{count=count+$1}}END{{print count}}') 
            echo ${{id}} ${{snps}} >> {output[0]}
        done
        """


        
rule merge_stats_pairs_calculation:
    input:
        expand("typing/{{snp_caller}}/core_parsnp/{{ref}}/{{mapping_method}}/{sample1}_{sample2}_stats.txt", zip, sample1 = s1, sample2 = s2),
        expand("strains/{sample}/snps/{{snp_caller}}/{{ref}}/{{mapping_method}}/final_stats.txt", sample=read_naming.keys())
    output:
        "typing/{snp_caller}/core_parsnp/{ref}/{mapping_method}/distances.txt"
    shell:
        """
        for i in {input}
        do
            if [[ $i == typing/* ]]
            then
                id=$(echo ${{i}} | sed "s/^.*\///" | sed "s/_stats\.txt//" | sed "s/_/ /")
            else
                id="$(echo ${{i}} | sed "s/strains\///" | sed "s/\/.*//") {wildcards.ref}"
            fi
        
            snps=$(grep "^SN" ${{i}} | grep "SNPs" | awk '$2 !=2 {{print $NF}}' | awk '{{count=count+$1}}END{{print count}}') 
            echo ${{id}} ${{snps}} >> {output}
        done
        """


